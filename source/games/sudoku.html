<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”¢ æ•°ç‹¬ - ç‚œç…œä¹‹åšå®¢</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { color: #fff; margin-bottom: 15px; font-size: 2em; }
        .game-container {
            display: flex;
            gap: 40px;
            align-items: flex-start;
        }
        canvas { border-radius: 10px; box-shadow: 0 0 30px rgba(253, 203, 110, 0.3); }
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 200px;
        }
        .info-box {
            background: rgba(255,255,255,0.1);
            padding: 15px 20px;
            border-radius: 10px;
            color: #fff;
        }
        .info-label { color: #aaa; font-size: 0.9em; }
        .info-value { font-size: 1.5em; font-weight: bold; color: #fdcb6e; }
        .difficulty-btns {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .diff-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        .diff-btn.easy { background: #00b894; color: white; }
        .diff-btn.medium { background: #fdcb6e; color: #333; }
        .diff-btn.hard { background: #e17055; color: white; }
        .diff-btn.active { outline: 3px solid #fff; }
        .diff-btn:hover { transform: translateY(-2px); }
        
        .number-pad {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 15px;
        }
        .num-btn {
            padding: 15px;
            font-size: 1.2em;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
        }
        .num-btn:hover { background: rgba(255,255,255,0.2); transform: scale(1.1); }
        .num-btn.undo { background: #636e72; grid-column: span 5; }
        .num-btn.erase { background: #d63031; grid-column: span 5; }
        
        .controls {
            margin-top: 20px;
            color: #aaa;
            text-align: center;
        }
        .back-btn {
            display: inline-block;
            padding: 12px 30px;
            margin-top: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>ğŸ”¢ æ•°ç‹¬</h1>
    <div class="game-container">
        <canvas id="gameCanvas" width="500" height="500"></canvas>
        <div class="side-panel">
            <div class="info-box">
                <div class="info-label">éš¾åº¦</div>
                <div class="difficulty-btns">
                    <button class="diff-btn easy active" onclick="setDifficulty('easy')">ç®€å•</button>
                    <button class="diff-btn medium" onclick="setDifficulty('medium')">ä¸­ç­‰</button>
                    <button class="diff-btn hard" onclick="setDifficulty('hard')">å›°éš¾</button>
                </div>
            </div>
            <div class="info-box">
                <div class="info-label">å·²ç”¨æ—¶é—´</div>
                <div class="info-value" id="timer">00:00</div>
            </div>
            <div class="info-box">
                <div class="info-label">æç¤ºæ¬¡æ•°</div>
                <div class="info-value" id="hints">3</div>
            </div>
            <div class="info-box">
                <div class="info-label">é”™è¯¯æ¬¡æ•°</div>
                <div class="info-value" id="errors">0</div>
            </div>
            <div class="number-pad">
                <button class="num-btn" onclick="inputNumber(1)">1</button>
                <button class="num-btn" onclick="inputNumber(2)">2</button>
                <button class="num-btn" onclick="inputNumber(3)">3</button>
                <button class="num-btn" onclick="inputNumber(4)">4</button>
                <button class="num-btn" onclick="inputNumber(5)">5</button>
                <button class="num-btn" onclick="inputNumber(6)">6</button>
                <button class="num-btn" onclick="inputNumber(7)">7</button>
                <button class="num-btn" onclick="inputNumber(8)">8</button>
                <button class="num-btn" onclick="inputNumber(9)">9</button>
                <button class="num-btn" onclick="inputNumber(0)">0</button>
                <button class="num-btn undo" onclick="undo()">â†©ï¸ æ’¤é”€</button>
                <button class="num-btn erase" onclick="erase()">ğŸ—‘ï¸ æ¸…é™¤</button>
            </div>
        </div>
    </div>
    <div class="controls">
        <p>ğŸ¯ ç‚¹å‡»æ ¼å­ | âŒ¨ï¸ é”®ç›˜è¾“å…¥ 1-9 | ç©ºæ ¼é”®æ˜¾ç¤ºå€™é€‰æ•°</p>
    </div>
    <a href="index.html" class="back-btn">â† è¿”å›æ¸¸æˆé€‰æ‹©</a>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CELL_SIZE = 500 / 9;
        
        let puzzle = [];
        let solution = [];
        let fixed = [];
        let selected = { x: -1, y: -1 };
        let history = [];
        let hints = 3;
        let errors = 0;
        let startTime = null;
        let timerInterval = null;
        let difficulty = 'easy';
        let candidates = {};
        let showCandidates = false;
        
        function generateSudoku() {
            // ç”Ÿæˆå®Œæ•´æ•°ç‹¬
            solution = Array(9).fill(null).map(() => Array(9).fill(0));
            solve(solution);
            
            // æŒ–ç©º
            puzzle = solution.map(row => [...row]);
            fixed = solution.map(row => [...row]);
            
            let attempts = difficulty === 'easy' ? 35 : difficulty === 'medium' ? 45 : 55;
            while (attempts > 0) {
                const x = Math.floor(Math.random() * 9);
                const y = Math.floor(Math.random() * 9);
                if (puzzle[y][x] !== 0) {
                    puzzle[y][x] = 0;
                    attempts--;
                }
            }
            
            // é‡ç½®å›ºå®šæ•°ç»„
            fixed = puzzle.map((row, y) => row.map((val, x) => val !== 0));
        }
        
        function solve(board) {
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    if (board[y][x] === 0) {
                        const nums = [1,2,3,4,5,6,7,8,9];
                        shuffle(nums);
                        for (const num of nums) {
                            if (isValid(board, x, y, num)) {
                                board[y][x] = num;
                                if (solve(board)) return true;
                                board[y][x] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }
        
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function isValid(board, x, y, num) {
            for (let i = 0; i < 9; i++) {
                if (board[y][i] === num || board[i][x] === num) return false;
            }
            const boxX = Math.floor(x / 3) * 3;
            const boxY = Math.floor(y / 3) * 3;
            for (let dy = 0; dy < 3; dy++) {
                for (let dx = 0; dx < 3; dx++) {
                    if (board[boxY + dy][boxX + dx] === num) return false;
                }
            }
            return true;
        }
        
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, 500, 500);
            
            // ç»˜åˆ¶æ ¼å­
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    const px = x * CELL_SIZE;
                    const py = y * CELL_SIZE;
                    
                    // èƒŒæ™¯
                    ctx.fillStyle = ((x + y) % 2 === 0) ? '#2d3436' : '#363c44';
                    ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                    
                    // é€‰ä¸­é«˜äº®
                    if (selected.x === x && selected.y === y) {
                        ctx.fillStyle = 'rgba(253, 203, 110, 0.4)';
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                    }
                    
                    // æ•°å­—
                    if (puzzle[y][x] !== 0) {
                        ctx.fillStyle = fixed[y][x] ? '#74b9ff' : '#fdcb6e';
                        ctx.font = `bold ${CELL_SIZE * 0.6}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(puzzle[y][x], px + CELL_SIZE/2, py + CELL_SIZE/2);
                    } else if (showCandidates && candidates[`${x},${y}`]) {
                        ctx.fillStyle = '#636e72';
                        ctx.font = `${CELL_SIZE * 0.2}px Arial`;
                        const cands = candidates[`${x},${y}`].join(' ');
                        ctx.fillText(cands, px + CELL_SIZE/2, py + CELL_SIZE/2);
                    }
                }
            }
            
            // ç»˜åˆ¶è¾¹æ¡†
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, 500, 500);
            
            // 3x3 è¾¹æ¡†
            ctx.lineWidth = 3;
            for (let i = 1; i < 9; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE * 3, 0);
                ctx.lineTo(i * CELL_SIZE * 3, 500);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE * 3);
                ctx.lineTo(500, i * CELL_SIZE * 3);
                ctx.stroke();
            }
            
            requestAnimationFrame(draw);
        }
        
        function inputNumber(num) {
            if (selected.x < 0 || selected.y < 0) return;
            if (fixed[selected.y][selected.x]) return;
            
            // è®°å½•å†å²
            history.push({
                x: selected.x,
                y: selected.y,
                oldValue: puzzle[selected.y][selected.x],
                newValue: num
            });
            
            const oldValue = puzzle[selected.y][selected.x];
            puzzle[selected.y][selected.x] = num;
            
            if (num !== 0 && num !== solution[selected.y][selected.x]) {
                errors++;
                document.getElementById('errors').textContent = errors;
            }
            
            checkWin();
        }
        
        function undo() {
            if (history.length > 0) {
                const last = history.pop();
                puzzle[last.y][last.x] = last.oldValue;
            }
        }
        
        function erase() {
            inputNumber(0);
        }
        
        function hint() {
            if (hints <= 0) return;
            
            // æ‰¾åˆ°ä¸€ä¸ªç©ºæ ¼
            const empty = [];
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    if (puzzle[y][x] === 0) empty.push({x, y});
                }
            }
            
            if (empty.length > 0) {
                const pos = empty[Math.floor(Math.random() * empty.length)];
                const correct = solution[pos.y][pos.x];
                puzzle[pos.y][pos.x] = correct;
                history.push({
                    x: pos.x, y: pos.y, oldValue: 0, newValue: correct
                });
                hints--;
                document.getElementById('hints').textContent = hints;
                checkWin();
            }
        }
        
        function checkWin() {
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    if (puzzle[y][x] === 0 || puzzle[y][x] !== solution[y][x]) {
                        return;
                    }
                }
            }
            clearInterval(timerInterval);
            
            // ç»˜åˆ¶èƒœåˆ©ç”»é¢
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 500, 500);
            ctx.fillStyle = '#00b894';
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ğŸ‰ å®Œæˆ!', 250, 220);
            ctx.fillStyle = '#fff';
            ctx.font = '25px Arial';
            ctx.fillText(`ç”¨æ—¶: ${document.getElementById('timer').textContent}`, 250, 280);
            ctx.fillText(`é”™è¯¯: ${errors}æ¬¡`, 250, 320);
        }
        
        function setDifficulty(diff) {
            difficulty = diff;
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.diff-btn.${diff}`).classList.add('active');
            resetGame();
        }
        
        function resetGame() {
            puzzle = [];
            solution = [];
            fixed = [];
            selected = {x: -1, y: -1};
            history = [];
            hints = 3;
            errors = 0;
            showCandidates = false;
            document.getElementById('hints').textContent = hints;
            document.getElementById('errors').textContent = errors;
            generateSudoku();
            startTimer();
        }
        
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            startTime = Date.now();
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const sec = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('timer').textContent = `${min}:${sec}`;
            }, 1000);
        }
        
        // äº‹ä»¶ç›‘å¬
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);
            if (x >= 0 && x < 9 && y >= 0 && y < 9) {
                selected = {x, y};
            }
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key >= '1' && e.key <= '9') {
                inputNumber(parseInt(e.key));
            } else if (e.key === '0' || e.key === 'Backspace') {
                erase();
            } else if (e.key === ' ') {
                showCandidates = !showCandidates;
            } else if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
                undo();
            } else if (e.key === 'h') {
                hint();
            }
        });
        
        generateSudoku();
        startTimer();
        draw();
    </script>
</body>
</html>
