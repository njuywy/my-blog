<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§© è¿·å®«ç”Ÿæˆå™¨ - ç‚œç…œä¹‹åšå®¢</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { color: #fff; margin-bottom: 15px; font-size: 2em; }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 10px;
        }
        .control-group label { color: #aaa; }
        .control-group input[type="range"] { width: 100px; }
        .control-group span { color: #74b9ff; font-weight: bold; min-width: 30px; }
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        .btn:hover { transform: translateY(-2px); }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-success { background: linear-gradient(135deg, #00b894 0%, #00cec9 100%); color: white; }
        canvas { border-radius: 10px; box-shadow: 0 0 30px rgba(116, 185, 255, 0.3); }
        .info {
            display: flex;
            gap: 40px;
            margin-top: 20px;
            color: #fff;
        }
        .info-box {
            background: rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 10px;
        }
        .back-btn {
            display: inline-block;
            padding: 12px 30px;
            margin-top: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>ğŸ§© è¿·å®«ç”Ÿæˆå™¨</h1>
    <div class="controls">
        <div class="control-group">
            <label>å®½åº¦:</label>
            <input type="range" id="width" min="5" max="31" value="15" oninput="updateLabels()">
            <span id="widthLabel">15</span>
        </div>
        <div class="control-group">
            <label>é«˜åº¦:</label>
            <input type="range" id="height" min="5" max="21" value="11" oninput="updateLabels()">
            <span id="heightLabel">11</span>
        </div>
        <div class="control-group">
            <label>ç®—æ³•:</label>
            <select id="algorithm" style="padding: 5px;">
                <option value="dfs">æ·±åº¦ä¼˜å…ˆ (DFS)</option>
                <option value="prim">Primç®—æ³•</option>
                <option value="kruskal">Kruskalç®—æ³•</option>
                <option value="recursive">é€’å½’åˆ†å‰²</option>
            </select>
        </div>
        <button class="btn btn-primary" onclick="generateMaze()">ğŸ² ç”Ÿæˆè¿·å®«</button>
        <button class="btn btn-success" onclick="solveMaze()">ğŸ” æ±‚è§£è¿·å®«</button>
        <button class="btn" style="background: #636e72; color: white;" onclick="resetPlayer()">ğŸ”„ é‡ç½®ç©å®¶</button>
    </div>
    <canvas id="gameCanvas" width="620" height="460"></canvas>
    <div class="info">
        <div class="info-box">ğŸ® æŒ‰ WASD æˆ– â†‘â†“â†â†’ ç§»åŠ¨</div>
        <div class="info-box">ğŸ“ è¿·å®«å¤§å°: <span id="mazeSize">15 x 11</span></div>
        <div class="info-box">â±ï¸ æ­¥æ•°: <span id="steps">0</span></div>
    </div>
    <a href="index.html" class="back-btn">â† è¿”å›æ¸¸æˆé€‰æ‹©</a>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let maze = [];
        let width = 15;
        let height = 11;
        let cellSize = 40;
        let player = { x: 0, y: 0 };
        let solution = [];
        let showSolution = false;
        let steps = 0;
        
        function updateLabels() {
            width = parseInt(document.getElementById('width').value);
            height = parseInt(document.getElementById('height').value);
            document.getElementById('widthLabel').textContent = width;
            document.getElementById('heightLabel').textContent = height;
            document.getElementById('mazeSize').textContent = `${width} x ${height}`;
        }
        
        function generateMaze() {
            const algo = document.getElementById('algorithm').value;
            const cols = width * 2 + 1;
            const rows = height * 2 + 1;
            
            // åˆå§‹åŒ–è¿·å®«ï¼ˆå…¨å¢™ï¼‰
            maze = Array(rows).fill(null).map(() => Array(cols).fill(1));
            
            switch(algo) {
                case 'dfs':
                    dfsGenerate(1, 1);
                    break;
                case 'prim':
                    primGenerate();
                    break;
                case 'kruskal':
                    kruskalGenerate();
                    break;
                case 'recursive':
                    recursiveGenerate(1, 1, cols - 2, rows - 2);
                    break;
            }
            
            // è®¾ç½®å…¥å£å’Œå‡ºå£
            maze[1][0] = 0; // å…¥å£
            maze[rows - 2][cols - 1] = 0; // å‡ºå£
            
            player = { x: 0, y: 1 };
            solution = [];
            showSolution = false;
            steps = 0;
            document.getElementById('steps').textContent = '0';
            
            cellSize = Math.min(40, Math.floor(600 / (width * 2 + 1)));
            canvas.width = (width * 2 + 1) * cellSize;
            canvas.height = (height * 2 + 1) * cellSize;
            
            draw();
        }
        
        function dfsGenerate(x, y) {
            const cols = width * 2 + 1;
            const rows = height * 2 + 1;
            const dirs = [[0, -2], [2, 0], [0, 2], [-2, 0]];
            shuffle(dirs);
            
            maze[y][x] = 0;
            
            for (const [dx, dy] of dirs) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx > 0 && nx < cols - 1 && ny > 0 && ny < rows - 1 && maze[ny][nx] === 1) {
                    maze[y + dy/2][x + dx/2] = 0;
                    dfsGenerate(nx, ny);
                }
            }
        }
        
        function primGenerate() {
            const cols = width * 2 + 1;
            const rows = height * 2 + 1;
            const walls = [];
            
            maze[1][1] = 0;
            addWalls(1, 1, walls);
            
            while (walls.length > 0) {
                const wall = walls.splice(Math.floor(Math.random() * walls.length), 1)[0];
                const x = wall.x;
                const y = wall.y;
                
                const cell1 = { x: (x + wall.dirX) / 2, y: (y + wall.dirY) / 2 };
                const cell2 = { x: (x - wall.dirX) / 2, y: (y - wall.dirY) / 2 };
                
                if (maze[cell1.y][cell1.x] === 1 && maze[cell2.y][cell2.x] === 0) {
                    maze[y][x] = 0;
                    maze[cell1.y][cell1.x] = 0;
                    addWalls(cell1.x, cell1.y, walls);
                }
            }
        }
        
        function addWalls(x, y, walls) {
            const dirs = [[0, -2], [2, 0], [0, 2], [-2, 0]];
            for (const [dx, dy] of dirs) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx > 0 && nx < width * 2 && ny > 0 && ny < height * 2) {
                    if (maze[ny][nx] === 1) {
                        walls.push({ x: nx, y: ny, dirX: dx, dirY: dy });
                    }
                }
            }
        }
        
        function kruskalGenerate() {
            const cols = width * 2 + 1;
            const rows = height * 2 + 1;
            const sets = [];
            const walls = [];
            
            // åˆå§‹åŒ–å¹¶æŸ¥é›†å’Œå¢™å£
            for (let y = 1; y < rows; y += 2) {
                for (let x = 1; x < cols; x += 2) {
                    sets.push({ x, y, id: sets.length });
                }
            }
            
            for (let y = 1; y < rows; y += 2) {
                for (let x = 1; x < cols; x += 2) {
                    if (x < cols - 2) walls.push({ x: x + 1, y, dirX: 2, dirY: 0 });
                    if (y < rows - 2) walls.push({ x, y: y + 1, dirX: 0, dirY: 2 });
                }
            }
            
            shuffle(walls);
            
            const find = (sets, x, y) => {
                for (let i = 0; i < sets.length; i++) {
                    if (sets[i].x === x && sets[i].y === y) {
                        return sets[i].id;
                    }
                }
                return -1;
            };
            
            for (const wall of walls) {
                const id1 = find(sets, wall.x - wall.dirX/2, wall.y - wall.dirY/2);
                const id2 = find(sets, wall.x + wall.dirX/2, wall.y + wall.dirY/2);
                
                if (id1 !== id2) {
                    maze[wall.y][wall.x] = 0;
                    maze[wall.y - wall.dirY/2][wall.x - wall.dirX/2] = 0;
                    maze[wall.y + wall.dirY/2][wall.x + wall.dirX/2] = 0;
                    
                    for (const s of sets) {
                        if (s.id === id2) s.id = id1;
                    }
                }
            }
        }
        
        function recursiveGenerate(x1, y1, x2, y2) {
            if (x2 - x1 < 2 || y2 - y1 < 2) return;
            
            const x = Math.floor((x1 + x2) / 2);
            const y = Math.floor((y1 + y2) / 2);
            
            maze[y][x] = 0;
            
            // éšæœºæ‰“å¼€å¢™å£
            const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            shuffle(dirs);
            
            for (let i = 0; i < 3; i++) {
                const [dx, dy] = dirs[i];
                const nx = x + dx;
                const ny = y + dy;
                if (nx > x1 && nx < x2 && ny > y1 && ny < y2) {
                    maze[ny][nx] = 0;
                }
            }
            
            recursiveGenerate(x1, y1, x, y);
            recursiveGenerate(x, y1, x2, y);
            recursiveGenerate(x1, y, x, y2);
            recursiveGenerate(x, y, x2, y2);
        }
        
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function solveMaze() {
            const cols = width * 2 + 1;
            const rows = height * 2 + 1;
            const start = { x: 0, y: 1 };
            const end = { x: cols - 1, y: rows - 2 };
            
            solution = [];
            const visited = Array(rows).fill(null).map(() => Array(cols).fill(false));
            const queue = [{ ...start, path: [] }];
            visited[start.y][start.x] = true;
            
            const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            
            while (queue.length > 0) {
                const { x, y, path } = queue.shift();
                
                if (x === end.x && y === end.y) {
                    solution = path;
                    showSolution = true;
                    draw();
                    return;
                }
                
                for (const [dx, dy] of dirs) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && 
                        maze[ny][nx] === 0 && !visited[ny][nx]) {
                        visited[ny][nx] = true;
                        queue.push({ x: nx, y: ny, path: [...path, { x: nx, y: ny }] });
                    }
                }
            }
        }
        
        function resetPlayer() {
            player = { x: 0, y: 1 };
            steps = 0;
            document.getElementById('steps').textContent = '0';
            showSolution = false;
            draw();
        }
        
        function draw() {
            const cols = width * 2 + 1;
            const rows = height * 2 + 1;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è¿·å®«
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = '#2d3436';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    } else {
                        ctx.fillStyle = '#0a0a0a';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            // ç»˜åˆ¶è·¯å¾„
            if (showSolution) {
                ctx.strokeStyle = 'rgba(0, 184, 148, 0.5)';
                ctx.lineWidth = cellSize * 0.4;
                ctx.lineCap = 'round';
                ctx.beginPath();
                solution.forEach((p, i) => {
                    const px = p.x * cellSize + cellSize / 2;
                    const py = p.y * cellSize + cellSize / 2;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });
                ctx.stroke();
            }
            
            // ç»˜åˆ¶å…¥å£å’Œå‡ºå£
            ctx.fillStyle = '#00b894';
            ctx.fillRect(0, cellSize, cellSize, cellSize);
            ctx.fillStyle = 'å…¥å£';
            ctx.font = `${cellSize * 0.3}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('å…¥å£', cellSize/2, cellSize + cellSize/2);
            
            ctx.fillStyle = '#e17055';
            ctx.fillRect((cols - 1) * cellSize, (rows - 2) * cellSize, cellSize, cellSize);
            ctx.fillStyle = '#fff';
            ctx.fillText('å‡ºå£', (cols - 1) * cellSize + cellSize/2, (rows - 2) * cellSize + cellSize/2);
            
            // ç»˜åˆ¶ç©å®¶
            const px = player.x * cellSize + cellSize / 2;
            const py = player.y * cellSize + cellSize / 2;
            
            ctx.fillStyle = '#74b9ff';
            ctx.beginPath();
            ctx.arc(px, py, cellSize * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(px - cellSize * 0.15, py - cellSize * 0.1, cellSize * 0.1, 0, Math.PI * 2);
            ctx.arc(px + cellSize * 0.15, py - cellSize * 0.1, cellSize * 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#2d3436';
            ctx.beginPath();
            ctx.arc(px - cellSize * 0.15, py - cellSize * 0.1, cellSize * 0.05, 0, Math.PI * 2);
            ctx.arc(px + cellSize * 0.15, py - cellSize * 0.1, cellSize * 0.05, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;
            const cols = width * 2 + 1;
            const rows = height * 2 + 1;
            
            if (newX >= 0 && newX < cols && newY >= 0 && newY < rows && maze[newY][newX] === 0) {
                player.x = newX;
                player.y = newY;
                steps++;
                document.getElementById('steps').textContent = steps;
                
                // æ£€æŸ¥èƒœåˆ©
                if (newX === cols - 1 && newY === rows - 2) {
                    setTimeout(() => {
                        alert(`ğŸ‰ æ­å–œé€šå…³ï¼\nç”¨æ—¶ ${steps} æ­¥`);
                    }, 100);
                }
                
                draw();
            }
        }
        
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    movePlayer(0, -1);
                    break;
                case 's':
                case 'arrowdown':
                    movePlayer(0, 1);
                    break;
                case 'a':
                case 'arrowleft':
                    movePlayer(-1, 0);
                    break;
                case 'd':
                case 'arrowright':
                    movePlayer(1, 0);
                    break;
            }
        });
        
        updateLabels();
        generateMaze();
    </script>
</body>
</html>
